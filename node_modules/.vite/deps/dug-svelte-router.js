import {
  SvelteComponentDev,
  add_location,
  append_dev,
  attr_dev,
  check_outros,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  group_outros,
  init,
  insert_dev,
  mount_component,
  safe_not_equal,
  set_style,
  space,
  transition_in,
  transition_out,
  validate_each_argument,
  validate_slots
} from "./chunk-PUOMPBAM.js";

// node_modules/.pnpm/dug-svelte-router@0.1.1_svelte@3.58.0/node_modules/dug-svelte-router/dist/Router.svelte
var file = "node_modules/.pnpm/dug-svelte-router@0.1.1_svelte@3.58.0/node_modules/dug-svelte-router/dist/Router.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[13] = i;
  const constants_0 = (
    /*mountAll*/
    child_ctx[1] || /*route*/
    child_ctx[7].mount
  );
  child_ctx[8] = constants_0;
  const constants_1 = (
    /*destroyAll*/
    child_ctx[2] || /*route*/
    child_ctx[7].destroy
  );
  child_ctx[9] = constants_1;
  const constants_2 = [
    /*actives*/
    child_ctx[3][
      /*index*/
      child_ctx[13]
    ],
    /*loads*/
    child_ctx[4][
      /*index*/
      child_ctx[13]
    ]
  ];
  child_ctx[10] = constants_2[0];
  child_ctx[11] = constants_2[1];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*loaded*/
    ctx[11] && create_if_block_6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*loaded*/
        ctx2[11]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*actives, loads*/
          24) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(54:29) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*loaded*/
    ctx[11] && /*active*/
    ctx[10] && create_if_block_4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*loaded*/
        ctx2[11] && /*active*/
        ctx2[10]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*actives, loads*/
          24) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(50:28) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let span;
  let switch_instance;
  let t;
  let current;
  var switch_value = (
    /*route*/
    ctx[7].component
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      span = element("span");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr_dev(span, "class", "__dug-route-wrapper");
      set_style(
        span,
        "display",
        /*active*/
        ctx[10] ? "inline" : "none"
      );
      add_location(span, file, 46, 4, 1347);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (switch_instance)
        mount_component(switch_instance, span, null);
      append_dev(span, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*routes*/
      1 && switch_value !== (switch_value = /*route*/
      ctx2[7].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty & /*actives, loads*/
      24) {
        set_style(
          span,
          "display",
          /*active*/
          ctx2[10] ? "inline" : "none"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(46:28) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (!/*loaded*/
  ctx[11] || /*active*/
  ctx[10] && /*loaded*/
  ctx[11]) && create_if_block_1(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*loaded*/
      ctx2[11] || /*active*/
      ctx2[10] && /*loaded*/
      ctx2[11]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*actives, loads*/
          24) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(40:0) {#if mount && destroy}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let span;
  let switch_instance;
  let t;
  let current;
  var switch_value = (
    /*route*/
    ctx[7].component
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      span = element("span");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr_dev(span, "class", "__dug-route-wrapper");
      set_style(
        span,
        "display",
        /*active*/
        ctx[10] ? "inline" : "none"
      );
      add_location(span, file, 55, 8, 1666);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (switch_instance)
        mount_component(switch_instance, span, null);
      append_dev(span, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*routes*/
      1 && switch_value !== (switch_value = /*route*/
      ctx2[7].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty & /*actives, loads*/
      24) {
        set_style(
          span,
          "display",
          /*active*/
          ctx2[10] ? "inline" : "none"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(55:4) {#if loaded}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*route*/
    ctx[7].component
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*routes*/
      1 && switch_value !== (switch_value = /*route*/
      ctx2[7].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(51:4) {#if loaded && active}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let span;
  let switch_instance;
  let t;
  let current;
  var switch_value = (
    /*route*/
    ctx[7].component
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      span = element("span");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr_dev(span, "class", "__dug-route-wrapper");
      set_style(
        span,
        "display",
        /*active*/
        ctx[10] ? "inline" : "none"
      );
      add_location(span, file, 41, 8, 1150);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (switch_instance)
        mount_component(switch_instance, span, null);
      append_dev(span, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*routes*/
      1 && switch_value !== (switch_value = /*route*/
      ctx2[7].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty & /*actives, loads*/
      24) {
        set_style(
          span,
          "display",
          /*active*/
          ctx2[10] ? "inline" : "none"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(41:4) {#if !loaded || active && loaded}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_2, create_if_block_3, create_if_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*mount*/
      ctx2[8] && /*destroy*/
      ctx2[9]
    )
      return 0;
    if (
      /*mount*/
      ctx2[8] && !/*destroy*/
      ctx2[9]
    )
      return 1;
    if (!/*mount*/
    ctx2[8] && /*destroy*/
    ctx2[9])
      return 2;
    if (!/*mount*/
    ctx2[8] && !/*destroy*/
    ctx2[9])
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(35:0) {#each routes as route, index}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*routes*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*actives, loads, routes, mountAll, destroyAll*/
      31) {
        each_value = /*routes*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { routes = [] } = $$props;
  let actives = routes.map((x) => false);
  let loads = routes.map((x) => false);
  let currentHash = window.location.hash;
  let { mountAll = false } = $$props;
  let { destroyAll = false } = $$props;
  scanRoutes();
  window.addEventListener("hashchange", () => {
    currentHash = window.location.hash;
    scanRoutes();
  });
  function scanRoutes() {
    routes.forEach((route, index) => {
      $$invalidate(
        3,
        actives[index] = route.hash ? route.hash.startsWith("layout:") ? currentHash.startsWith(route.hash.split(":")[1]) : currentHash === route.hash : currentHash === "" || currentHash === "#",
        actives
      );
      if (actives[index])
        $$invalidate(4, loads[index] = true, loads);
    });
    $$invalidate(0, routes);
  }
  const writable_props = ["routes", "mountAll", "destroyAll"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("routes" in $$props2)
      $$invalidate(0, routes = $$props2.routes);
    if ("mountAll" in $$props2)
      $$invalidate(1, mountAll = $$props2.mountAll);
    if ("destroyAll" in $$props2)
      $$invalidate(2, destroyAll = $$props2.destroyAll);
  };
  $$self.$capture_state = () => ({
    routes,
    actives,
    loads,
    currentHash,
    mountAll,
    destroyAll,
    scanRoutes
  });
  $$self.$inject_state = ($$props2) => {
    if ("routes" in $$props2)
      $$invalidate(0, routes = $$props2.routes);
    if ("actives" in $$props2)
      $$invalidate(3, actives = $$props2.actives);
    if ("loads" in $$props2)
      $$invalidate(4, loads = $$props2.loads);
    if ("currentHash" in $$props2)
      currentHash = $$props2.currentHash;
    if ("mountAll" in $$props2)
      $$invalidate(1, mountAll = $$props2.mountAll);
    if ("destroyAll" in $$props2)
      $$invalidate(2, destroyAll = $$props2.destroyAll);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [routes, mountAll, destroyAll, actives, loads];
}
var Router = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { routes: 0, mountAll: 1, destroyAll: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router",
      options,
      id: create_fragment.name
    });
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mountAll() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mountAll(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get destroyAll() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set destroyAll(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router;
export {
  Router_default as Router
};
//# sourceMappingURL=dug-svelte-router.js.map
